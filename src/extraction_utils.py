from vertexai.generative_models import GenerativeModel, GenerationConfig, Part
import json
import mimetypes

def parse_json(response):
    """
    Tries to parse the output from the LLM model into valid JSON.
    If the schema is not valid JSON, it returns the error message.

    Args:
        response (str): The text generated by the LLM model.

    Returns:
        dict or str: Returns the parsed JSON schema if valid, otherwise returns the error message.
    """
    try:
        response_json = json.loads(response)
        print(f"Key-values generated successfully.")
        return response_json
    except json.JSONDecodeError as e:
        # Return the error message if JSON parsing fails
        return f"JSONDecodeError"
    
    
def extract_key_values_from_document(file_uri, schema, examples, response_schema, model_name):

    """
    Extract key-value pairs from a given document based on the provided schema using a language model.

    Args:
        file_uri (str): URI of the document to process.
        schema (list): List of schema items to use for extraction.
        response_schema (dict): JSON schema to control the output format.
        model_name (str): Generative AI model for key-value pairs extraction.

    Returns:
        dict: Extracted key-value pairs in the desired format.
    """
        
    # Format the schema nicely for the prompt with newlines
    formatted_schema = "\n".join([str(field) for field in schema])
    formatted_examples = "\n".join([str(row) for row in examples])

    # Create the improved prompt with clear instructions
    prompt = f"""
    You are given a document containing details. Your task is to extract key-value pairs from the document according to the following schema: \n

    {formatted_schema}

    \n Use this schema to extract the specified information from the document.\n
    
    Please adhere closely to the following guidelines when extracting values: \n

    1. **Style Consistency:** Below are some example rows from the existing table: \n

    {formatted_examples}
    \n
    Use these examples as references for the style and format of the extracted values. Match the style of values as seen in these rows, ensuring consistency in abbreviations, capitalization, and wording. For example, if 'country' is listed as "US" in the examples, format extracted values for 'country' as "US" instead of "United States." Consistency in style across similar documents is crucial to ensure values align with the provided examples. \n
    2. **Consistent Terminology Across Similar Terms**: Always match the exact terminology found in the example rows, even for terms that may seem synonymous. If the document includes variations of a term (e.g., "health insurance," "health," "health benefits"), use only the term specified in the examples (e.g., "health insurance") for all similar items. Do not introduce new variations, synonyms, or extended descriptions. For instance:  \n
        - If the example uses "medical insurance," do not extract as "health insurance" or "health coverage."  \n
        - If "401(k)" is listed in the examples, use only "401(k)" instead of terms like "401(k) retirement plan." \n
    3. **Concise Keywords for Strings and Lists:** Extract only short, essential keywords for columns of type "STRING" or "ARRAY/LIST (REPEATED)." Avoid phrases or descriptions longer than a few words. For instance: \n
        - If a document provides a long phrase like "Comprehensive benefits including medical, dental, vision," simplify to ["medical insurance", "dental insurance", "vision insurance"]. \n
        - If long phrases are and cannot be made shorter or simplified to less terms, do not extract or include in the extracted terms or values. \n
    4. PLEASE ADHERE STRICTLY TO RULES 2 and 3. THEY ARE VERY IMPORTANT. \n    
    5. **Handling Missing Information:** If required information is not found or cannot be logically inferred from the document: \n
        - For columns of type REPEATED (i.e., lists/arrays), return an empty list ([]). This ensures compatibility with BigQuery, as an empty field would otherwise result in an insert error: “Field value cannot be empty.” \n
        - For all other columns, return NULL (represented as None in Python). \n
    Adhering strictly to these requirements is essential to avoid insertion errors and ensure data consistency. \n
    6. **Inferring Values for Schema Columns:** If a column in the schema does not have a direct value in the document but can be logically inferred from available information, derive and populate that value. For instance, if a document includes "Estes Park, CO" in the location, infer values for related columns in the schema, such as 'country' ("US") and 'state' ("CO"). Only infer values that can be logically reasoned based on the document’s content, ensuring alignment with the schema. \n
    7. **Output Format:** Return the extracted data strictly in JSON format, ensuring that each key in the JSON output matches exactly with the field names from the schema. \n
    
    This schema will be used to process and extract data from similar documents in future batches, so ensure values are formatted in a way that is consistent and can be applied uniformly across documents of the same type. \n
    Final Reminder: Ensure extracted data is concise, using short, standardized keywords that align with the provided examples. \n
    """

    # Initialize the model
    model = GenerativeModel(model_name)

    mime_type, _ = mimetypes.guess_type(file_uri)

    file = Part.from_uri(
        uri=file_uri,
        mime_type=mime_type,
    )

    # Combine the contents and the dynamically generated prompt
    contents = [file, prompt]

    # Generate the structured output
    response = model.generate_content(
        contents,
        generation_config=GenerationConfig(
            temperature = 1,
            response_mime_type="application/json",
            response_schema=response_schema
        ),
    )

    response_json = parse_json(response.text)
              
    return response_json